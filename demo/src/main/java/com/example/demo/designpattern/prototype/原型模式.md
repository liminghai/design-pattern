
# 1. 什么是原型模式

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）
进行复制（或者叫拷贝）的方式，来创建新的对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫做原型设计模式，简称原型模式。

# 2. 原型模式的两种实现方法

原型模式有两种实现方法，深拷贝和浅拷贝。

## 2.1 浅拷贝
浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象。

## 2.2 深拷贝
深拷贝得到的是一份完完全全独立的对象。所以深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。

# 3. 优点
## 3.1 性能优良
原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时。

## 3.2 逃避构造函数的约束
原型模式直接在内存中拷贝，构造函数是不会被执行的。

# 4. 使用场景
## 4.1 资源优化场景
类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源。

## 4.2 性能和安全优化场景
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

## 4.3 一个对象多个修改者的场景

# 5. 代码实现
## 5.1 通过实现Cloneable接口来标识这个对象有可能被拷贝；
```
Cloneable接口中一个方法都没有，这个接口只是一个标记作用，在JVM中具有这个标记的对象才有可能被拷贝。
```
## 5.2 重写clone()方法，通过该方法进行对象的拷贝。
```
public class Mail implements Cloneable{

    // 收件人
    private String receiver;
    //邮件名称
    private String subject;
    //称谓
    private String appellation;
    //邮件内容
    private String content;
    //邮件尾部，一般都是加上"xxx版权所有"等信息
    private String tail;

    public Mail(String content, String subject){
        this.content = content;
        this.subject = subject;

    }

    @Override
    protected Mail clone() {
        Mail mail = null;

        try {
            mail = (Mail)super.clone();
        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }

        return mail;
    }

    // 省流getter setter......

}
```

# 6. 原型模式注意事项
## 6.1 构造函数不会被执行
Object类的clone方法的原理是：从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块。
那构造函数没有被执行是最正常不过的事情。

## 6.2 浅拷贝和深拷贝
浅拷贝：Object类提供的clone方法只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址。

```
（1）内部的数组和引用对象才不拷贝，其他的原始类型比如int、long、char等都会被拷贝。
（2）如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的；但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，
    就有可能出现数据被修改的风险。
```

## 6.3 总结
在浅拷贝的时候，如果该类只有基本数据类型和包装类对象，那么浅拷贝是安全的。因为基本数据类型是值传递，而包装类是不可变数据类型。