
# 1. 基本概念
**观察者模式，也被称为发布订阅模式。**

定义：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

# 2. 为什么需要观察者模式
**以达到OCP目标为目的。**

假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发送投资体验金。代码实现大致如下：
```
public class UserController {

    @Autowired
    private UserService userService;
    @Autowired
    private PromotionService promotionService;

    public Long register(String telephone, String password) {
        // 省略输入参数的校验代码
        // 省略userService.register()异常的try-catch代码

        long userId = userService.register(telephone, password);
        promotionService.issueNewUserExperienceCash(userId);

        return userId;
    }
}
```

虽然注册接口做了两件事情，注册和发送体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。
如果非得用观察者模式，就需要引入更多的类和更复杂的代码结构，反倒是一种过度设计。

相反，如果需求频繁改动，比如，用户注册成功之后，不再发送体验金，而是改为发送优惠券，并且还给用户发送一封"注册成功"的站内信。
这种情况下，我们就需要频繁的修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，
那register()函数的逻辑会变得越来越复杂，也就影响了代码的可读性和可维护性。

这个时候，观察者模式就能派上用场了。

## 2.1 小总结
设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同的功能代码解耦，行为型模式是将不同的行为代码
进行解耦。具体到观察者模式，它是将观察者和被观察者代码解耦。


# 3. 基于不同应用场景的不同实现方式

## 3.1 进程内的实现方式
### 3.1.1 同步阻塞
自己维护观察者列表，被观察者每次遍历通知观察者列表

### 3.1.2 异步非阻塞
EventBus

## 3.2 进程间的实现方式（消息队列）
- 好处

在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。

而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。**被观察者完全不感知观察者，同理，观察者也完全不感知被观察者**。
被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。

- 弊端
引入一个新的消息系统，增加了维护成本。

# 4. 讨论

## 4.1 "生产者-消费者"模型和观察者模式的区别和联系
发布-订阅模型，是一对多的关系，可以以同步的方式实现，也可以以异步的方式实现。
生产-消费模型，是多对多的关系，一般以异步的方式实现。

两者都可以达到解耦的作用。








